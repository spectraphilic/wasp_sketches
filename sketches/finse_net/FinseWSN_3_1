/*
 SCRIPT for Finse network, to synchronize DM network, and read set of sensors
 April 2017, Simon Filhol, J. David Ibanez


 Script description: 
This script will get the waspmote to behave as a data logger potentially as part of distributed network

  1. trigger sensor 
  2. measure values
  3. store data into frame format
  4. if network is activated, will attempt sending the data using the digiMesh protocol
  5. got to sleep until next alarm is triggered

Check the list of actions in the battery 

The sampling frequency can be set within the variable 'samplings'. Associated behavior based on battery level are also to be adjusted to user preference

The network frequency and respective battery level behavior must be set too

To refine the triggering of actions. It is then possible to alter the filters here below.

 */


///////////////////////////////////////////////////////////////////////////////////////
//                       DEFINITIONS   ---  DO NOT ALTER!
///////////////////////////////////////////////////////////////////////////////////////

// 1. Include Libraries
#include <WaspUIO.h>
#include <WaspSensorAgr_v20.h>
#include <WaspFrame.h>
#include <WaspXBeeDM.h>

// 2. Definitions
// Defining the Action variable structure
typedef struct {
  unsigned long ms; // ms after the loop start when to run the action
  uint8_t (*action)(); // function (action) to call
  bool (*filter)(); // filter function, see documentation below
  char name[50];
} Action;


// 3. Global variables declaration
uint8_t error;
const char* alarmTime;
int pendingPulses;
int randomNumber;
uint8_t batteryLevel;


///////////////////////////////////////////////////////////////////////////////////////
//                       BASICS USER SETTINGS
///////////////////////////////////////////////////////////////////////////////////////

// Sampling period in minutes, keep these two definitions in sync. The value
// must be a factor of 60 to get equally spaced samples.
// Possible values: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30
// Different values for different battery levels.
const uint8_t samplings[] PROGMEM = {15, 10, 5};


///////////////////////////////////////////////////////////////////////////////////////
// Can we create just along the sampling scheme two arrays for the battery threshold that the only adjustement one has to do in the field is located within this section only
const uint8_t batteryThresholdSampling[] PROGMEM = {35, 45}; // WARNING: below 30% battery level, the waspmote does nothing
const uint8_t batteryThresholdNetwork[] PROGMEM = {55, 65};

// somethgin which would be really nice would be to print these time and battery values in the 'variables' menu. To us they are really important and helpful when deploying a station


// some instrument denpending on their design can still drain power even thought they are off. we should include a way to prevent using sensor power if not necessary
bool power3V3_ON = TRUE;
bool power5V_ON = FALSE;

// also rename sensor power functions on with one for the 3V3 and another for 5V




/////////////////////////////////////////////////////////////////////////////////////////
//                       FILTERS 
/////////////////////////////////////////////////////////////////////////////////////////

// Filter functions, to be used in the actions table below.
// These functions return true if the action is to be done, false if not.
// The decission is based in battery level and/or time.

bool filter_gps()
{
  // The RTC is DS3231SN which at -40 C has an accuracy of 3.5ppm, that's
  // about 0.3s per day, with aging it may be worse.
  // See https://www.maximintegrated.com/en/app-notes/index.mvp/id/3566

  // As clock sync between the devices is critical for the network to work
  // properly, we update the RTC time from GPS daily. But the GPS draws power,
  // so this may need to be tuned.
  return (UIO.time.day % 3 == 0);
}

bool filter_network()
{
  return (

    (UIO.featureNetwork &&
    UIO.time.hour % 2 == 0) & // XXX Every 2h

    ((batteryLevel > 75) ||                // Once an hour
    (batteryLevel > 55 && UIO.time.hour % 12 == 0)) 
  );
}

bool sendFramesFilter()
{
  if (! UIO.hasSD)
  {
    return false;
  }

  if (! filter_network()) { return false; } // Net ops happen once/hour at most
  return (
    (batteryLevel > 75) ||                // Once an hour
    (batteryLevel > 55 && UIO.time.hour % 12 == 0)  // Once every 3 hours
  );
}

bool filter_sdi12()
{
  return ((UIO.sensors & SENSOR_SDI12_CDT10) );        
}

bool filter_pressure()
{
  return (UIO.sensors & SENSOR_AGR_PRESSURE);
}

bool filter_lw()
{
  return (UIO.sensors & SENSOR_AGR_LEAFWETNESS);
}

bool filter_sensirion()
{
  return (UIO.sensors & SENSOR_AGR_SENSIRION);
}

bool filter_sensors3V3Power()
{
  return power3V3_ON;
}

bool filter_sensors5VPower()
{
  return power5V_ON;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                               TABLE OF ACTION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Include documentation on how time to add or delete actions to the table

// Array of actions, must be ordered by ms, will be executed in order.
//

const Action actions[] PROGMEM = {

// { time(millis),   &action to call        &filter (boolean),                  Log information     },

  {    0, &WaspUIO::sensors3V3PowerOn,      &filter_sensors3V3Power,            "Sensors 3V3 power On"},          // ~11ms
  {    0, &WaspUIO::sensors5VPowerOn,       &filter_sensors5VPower,             "Sensors 5V power On"},          // 

  {    0, &WaspUIO::startNetwork,           &filter_network,                    "Start network"},             // ~557ms ?
  // Internal sensors (health)

  //{  100, &WaspUIO::readACC,              NULL,                               "Read ACC"},                // ~37ms
  {  200, &WaspUIO::frameHealth,            NULL,                               "Create Health frame"},       // ~133ms
  // SDI-12
  {  500, &WaspUIO::SDI12_on,               &filter_sdi12,                      "SDI-12 turn ON"}, // ~500ms after 5V on
  {  600, &WaspUIO::SDI12_CTD10_measure,    &filter_sdi12,                      "SDI-12 CTD10, send Measure command"},
  { 1200, &WaspUIO::SDI12_CTD10_data,       &filter_sdi12,                      "SDI-12 CTD10, read data"}, // ~800ms after measure
  { 1300, &WaspUIO::SDI12_off,              &filter_sdi12,                      "SDI-12 turn OFF"},
  { 1400, &WaspUIO::SDI12_CTD10_frame,      &filter_sdi12,                      "SDI-12 CTD10 Create frame"},

 // Turn Off sensors, as soon as possible
  {    0, &WaspUIO::sensors3V3PowerOff,     &filter_sensors3V3Power,            "Sensors 3V3 power Off"},         // ~43ms ?
  {    0, &WaspUIO::sensors5VPowerOff,      &filter_sensors5VPower,             "Sensors 5V power Off"},         // 

  // The network window (8s minimum)
  {    0, &WaspUIO::sendFrames,             &sendFramesFilter,                  "Send frames"},               // ~59ms / frame
  { 8000, &WaspUIO::stopNetwork,            &filter_network,                    "Stop network"},              // ~43ms ?
  // GPS (once evry 3 days)
  { 9000, &WaspUIO::setTimeFromGPS,         &filter_gps,                        "Set RTC time from GPS"},
};

const uint8_t nActions = sizeof actions / sizeof actions[0];

const uint8_t getSampling() {
  uint8_t i = 2;

  if (batteryLevel <= 30)
  {
    i = 0;
  }
  else if (batteryLevel <= 40)
  {
    i = 1;
  }

  return pgm_read_byte_near(samplings + i);
}



///////////////////////////////////////////////////////////////////////////////////////
//                                  SETUP
///////////////////////////////////////////////////////////////////////////////////////


void setup()
{
  UIO.initTime();

  // Hard-code behaviour. Uncomment this if you do not wish to initialize
  // interactively.
  //UIO.updateEEPROM(EEPROM_UIO_FLAGS, FLAG_USB_OUTPUT);
  //UIO.initNet(NETWORK_BROADCAST);

  // Initialize variables, from EEPROM (USB print, OTA programming, ..)
  UIO.initVars();

  // Interactive mode
  UIO.start_RTC_SD_USB(false);
  UIO.interactive();

  // Create/Open files
  error = UIO.initSD();
  UIO.openFiles();

  // Set time from GPS if wrong time is detected
  // XXX Do this unconditionally to update location?
  if (UIO.epochTime < 1483225200) // 2017-01-01 arbitrary date in the past
  {
    UIO.logActivity(F("WARN Wrong time detected, updating from GPS"));
    UIO.setTimeFromGPS();
  }

  // Boot
  batteryLevel = PWR.getBatteryLevel();
  UIO.logActivity(F("INFO *** Booting (setup). Battery level is %d"), batteryLevel);

  // SDI-12
  // UIO.SDI12_CTD10_ident();

  // Set random seed, different for every device
  srandom(Utils.readSerialID());

  //UIO.readOwnMAC();

  // Calculate first alarm (requires batteryLevel)
  alarmTime = UIO.getNextAlarm(getSampling());

  // Go to sleep
  UIO.logActivity(F("INFO Boot done, go to sleep"));
  UIO.closeFiles();
  UIO.stop_RTC_SD_USB();
  PWR.deepSleep(alarmTime, RTC_ABSOLUTE, RTC_ALM1_MODE4, ALL_OFF);
}


///////////////////////////////////////////////////////////////////////////////////////
//                                LOOP
///////////////////////////////////////////////////////////////////////////////////////


void loop()
{
  uint8_t i;
  Action action;

  UIO.initTime();
  UIO.start_RTC_SD_USB(false);
  UIO.openFiles();

  // Update RTC time at least once. Keep minute and hour for later.
  RTC.breakTimeAbsolute(UIO.getEpochTime(), &UIO.time);

  // Check RTC interruption
  if (intFlag & RTC_INT)
  {
    // Battery level, do nothing if too low
    batteryLevel = PWR.getBatteryLevel();
    if (batteryLevel <= 30) {
      UIO.logActivity(F("DEBUG RTC interruption, low battery = %d"), batteryLevel);
      goto sleep;
    }

    UIO.logActivity(F("INFO *** RTC interruption, battery level = %d"), batteryLevel);
    //Utils.blinkGreenLED(); // blink green once every minute to show it is alive

    unsigned long start = millis();
    unsigned long diff;
    unsigned long t0;
    i = 0;
    while (i < nActions)
    {
      diff = UIO.millisDiff(start);
      memcpy_P(&action, &actions[i], sizeof action);

      // Filter
      if (action.filter != NULL && action.filter() == false)
      {
        UIO.logActivity(F("DEBUG Action %s: filtered"), action.name);
        i++;
        continue;
      }

      // Action
      if (action.ms < diff)
      {
        i++;
        t0 = millis();
        UIO.logActivity(F("DEBUG Action %s: start"), action.name);
        if (action.action())
        {
           UIO.logActivity(F("ERROR Action %s: error"), action.name);
        }
        else
        {
           UIO.logActivity(F("DEBUG Action %s: done in %lu ms"), action.name, UIO.millisDiff(t0));
        }
      }

      // Network (receive)
      if (xbeeDM.XBee_ON && xbeeDM.available())
      {
        UIO.logActivity(F("DEBUG New packet available"));
        UIO.receivePacket();
      }
    }
  }
  else
  {
    UIO.logActivity(F("WARN Unexpected interruption %d"), intFlag);
  }

sleep:
  // Calculate first alarm (requires batteryLevel)
  alarmTime = UIO.getNextAlarm(getSampling());

  UIO.logActivity(F("INFO Loop done in %lu ms."), UIO.millisDiff(UIO.start));
  //UIO.print(F("LOOP %lu"), UIO.millisDiff(UIO.start));
  UIO.closeFiles();
  UIO.stop_RTC_SD_USB();

  // Clear interruption flag & pin
  clearIntFlag();
  PWR.clearInterruptionPin();

  // Set whole agri board and waspmote to sleep, until next alarm.
  PWR.deepSleep(alarmTime, RTC_ABSOLUTE, RTC_ALM1_MODE4, ALL_OFF);
}
